{
    "contents" : "#' Subset, and/or summarize HarvestChoice 5-arc-minute spatial indicators\n#'\n#' Workhorse method to subset and/or aggregate HarvestChoice layers.\n#' This method also aggregates classified variables by continuous variables.\\\\\n#' e.g. \\code{getLayer(var=c(\"whea_h\", \"AEZ16_CLAS\"), by=c(\"ADM2_NAME_ALT\", \"bmi\"))}.\n#' It does so by returning the dominant class of a classified variable within each \\code{by}\n#' class, and by automatically classifying any continuous variable passed to \\code{by}\n#' using default value breaks as specified in the variable metadata.\n#' The formula used to aggregate classified variables by choosing the dominant class is\n#' \\code{names(sort(table({varCode}), decreasing=T)[1])}. This formula computes the\n#' frequency of each class, ranks them by decreasing frequency, and retains the top one.\n#' Layers can also be summarized over a spatial area (passed as an integer array of CELL5M ids).\n#' Note that calling \\code{getLayer(...)} is equivalent to using the convenience method\n#' \\code{hcapi(...)} with the same arguments.\n#'\n#' @param var character array of variable names (all types are accepted)\n#' @param iso3 optional array of country or regional codes to filter by (3-letter code)\n#' @param by optional character array of variables to group by (all types are accepted)\n#' @param ids optional gridcell ids to return (if collapse=F) or summarize by (if collapse=T)\n#' @param collapse if FALSE always return all pixel values (useful for plotting and to\n#' convert to spatial formats)\n#' @param as.class one of \"data.table\" (default) or \"list\". By default returns a simple data.table.\n#' If \\code{as.class=\"list\"} returns a well-constructed list with variable metadata\n#' @return a data.table (or json array) of \\code{var} indicators aggregated by \\code{by} domains\n#' @examples\n#' # Mean BMI and cassava yield across districts in Tanzania\n#' x <- hcapi(c(\"bmi\", \"cass_y\"), iso3=\"TZA\", by=c(\"ADM1_NAME_ALT\", \"ADM2_NAME_ALT\"))\n#' # Plot results for Mara province\n#' barchart(ADM2_NAME_ALT~bmi, data=x[ADM1_NAME_ALT==\"Mara\"])\n#'\n#' # Mean BMI and cassava yield across districts in Tanzania in GeoTIFF\n#' x <- hcapi(\"bmi\", iso3=\"TZA\", format=\"tif\")\n#'\n#' # Load the generated TIF raster (one band only)\n#' require(raster)\n#' x <- raster(x[1])\n#'\n#' # Plot the `bmi` series\n#' plot(x)\n#'\n#' # Equivalent request at the command line\n#' # curl http://hcapi.harvestchoice.org/ocpu/library/hcapi3/R/hcapi \\\n#' # -d '{\"var\":\"bmi\", \"iso3\":\"TZA\", \"format\":\"tif\"}' \\\n#' # -X POST -H 'Content-Type:application/json'\n#'\n#' # /ocpu/tmp/x0bc1ac9bdf/R/.val\n#' # /ocpu/tmp/x0bc1ac9bdf/stdout\n#' # /ocpu/tmp/x0bc1ac9bdf/warnings\n#' # /ocpu/tmp/x0bc1ac9bdf/source\n#' # /ocpu/tmp/x0bc1ac9bdf/console\n#' # /ocpu/tmp/x0bc1ac9bdf/info\n#' # /ocpu/tmp/x0bc1ac9bdf/files/bmi--TZA.tfw\n#' # /ocpu/tmp/x0bc1ac9bdf/files/bmi--TZA.tif\n#' # /ocpu/tmp/x0bc1ac9bdf/files/bmi--TZA.tif.aux.xml\n#' # /ocpu/tmp/x0bc1ac9bdf/files/DESCRIPTION\n#' # /ocpu/tmp/x0bc1ac9bdf/files/README\n#'\n#' # Use wget (at the command line) to download all generated files in a ZIP archive\n#' # wget http://hcapi.harvestchoice.org/ocpu/tmp/x0bc1ac9bdf/zip\n#'\n#' # The method may be expanded to summarize classified (discrete) variables by continuous\n#' # variables. For example the call below returns the dominant agro-ecological zone and\n#' # average stunting in children under 5 over Ivory Coast's provinces by elevation class\n#' hcapi(c(\"AEZ8_CLAS\", \"stunted_moderate\"), iso3=\"CIV\", by=c(\"ADM1_NAME_ALT\", \"ELEVATION\"))\n#'\n#' # An equivalent request at the command line\n#' # curl http://hcapi.harvestchoice.org/ocpu/library/hcapi3/R/hcapi/json \\\n#' # -d '{\"var\":[\"AEZ8_CLAS\",\"stunted_moderate\"], \"iso3\":\"CIV\", \"by\":[\"ADM1_NAME_ALT\",\"ELEVATION\"]}' \\\n#' # -X POST -H 'Content-Type:application/json'\n#'\n#' @export\ngetLayer <- function(var, iso3=\"SSA\", by=NULL, ids=NULL, collapse=TRUE, as.class=\"data.table\") {\n\n  setkey(vi, varCode)\n  # If pixel ids are passed ignore any country filter\n  if (length(ids)>0) iso3 <- \"SSA\"\n  # If \"SSA\" in iso3 then limit to SSA\n  if (\"SSA\" %in% iso3) iso3 <- \"SSA\"\n\n  # Validate list of variables\n  vars <- c(var, by)\n  vars <- vi[vars][is.na(varTitle), list(varCode, varTitle)][, varCode]\n  if (length(vars)>0) return(cat(\"Variable\", vars[1], \"was not found in HarvestChoice data catalog.\"))\n\n  if (length(by)>0) {\n    # Construct generic aggregation formula\n    setkey(vi, varCode)\n    agg <- vi[var][, aggFunR]\n    agg <- paste(var, agg, sep=\"=\")\n    agg <- paste(agg, collapse=\", \")\n\n    if (collapse==F) {\n      # Aggregate but don't collapse (for plotting and raster formats)\n      agg <- paste0(\"CELL5M, X, Y, \",  paste0(agg, collapse=\", \"))\n    }\n\n    # Construct `by` statement\n    switch(class(by),\n\n      `character` = {\n        # Simple array of variable codes\n        # If `by` include continuous variables, then auto-classify before grouping\n        bynum <- vi[by][!type==\"class\", varCode]\n        byclass <- setdiff(by, bynum)\n        fltr <- as.character(NA)\n\n        if (length(bynum)>0) {\n          # Classify using `classBreaks`\n          bynum <- sapply(bynum, function(i) {\n            b <- as.integer(unlist(strsplit(vi[i][, classBreaks], \"|\", fixed=T)))\n            paste0(i, \"=cut(\", i, \", c(\", paste(b, collapse=\", \"), \"), ordered_result=T)\")\n          })\n        }\n\n        bynum <- c(byclass, bynum)\n        bynum <- bynum[!is.na(bynum)]\n        bynum <- paste(bynum, collapse=\", \")\n      },\n\n      `list` = {\n        # Complex list with custom breaks and/or filters\n        # e.g. list(AEZ5_CLAS=c(\"abc\", \"xyz\"), TT_20K=c(2, 5))\n        # Filter\n        bynum <- vi[names(by)][!type==\"class\", varCode]\n        fltr <- setdiff(names(by), bynum)\n        fltr <- sapply(fltr, function(i) paste0(i,\n          \" %in% c('\", paste0(by[[i]], collapse=\"', '\"), \"')\"))\n        fltr <- paste0(fltr, collapse=\" & \")\n\n        # Classify\n        bynum <- sapply(bynum, function(i) paste0(i,\n          \"=cut(\", i, \", c(\", paste0(by[[i]], collapse=\", \"), \"), ordered_result=T)\"))\n        bynum <- paste0(bynum, collapse=\", \")\n        by <- names(by)\n      })\n\n    # Put it together\n    data <- paste0(\"dt\",\n      if(length(ids)>0) paste0(\"[CELL5M %in% c(\", paste0(ids, collapse=\",\"), \")]\"),\n      if(iso3!=\"SSA\") paste0(\"[ISO3 %in% c('\", paste0(iso3, collapse=\"','\"), \"')]\"),\n      if(!is.na(fltr)) paste0(\"[\", fltr, \"]\"),\n      \"[, list(\", agg, \"), by=list(\", bynum, \")]\")\n\n    # Eval in Rserve (through socket instead of DB connection)\n    # Uncomment to connect from remote host\n    # rc <- RS.connect(getOption(\"hcapi3.host\"), getOption(\"hcapi3.port\"), proxy.wait=F)\n    rc <- RS.connect(port=getOption(\"hcapi3.port\"), proxy.wait=F)\n    eval(parse(text=paste0(\"data <- RS.eval(rc, \", data, \")\")))\n    RS.close(rc)\n    #setkeyv(data, by)\n\n  } else {\n    # No aggregation. Don't duplicate any variable\n    vars <- c(g, var, by)\n    vars <- unique(vars)\n    vars <- vars[!is.na(vars)]\n\n    # Put it together\n    data <- paste0(\"dt\",\n      if(length(ids)>0) paste0(\"[CELL5M %in% c(\", paste0(ids, collapse=\",\"), \")]\"),\n      if(iso3!=\"SSA\") paste0(\"[ISO3 %in% c('\", paste0(iso3, collapse=\"','\"), \"')]\"),\n      \"[, list(\", paste0(vars, collapse=\", \"), \")]\")\n\n    # Eval in Rserve\n    rc <- RS.connect(getOption(\"hcapi3.host\"), getOption(\"hcapi3.port\"), proxy.wait=F)\n    eval(parse(text=paste0(\"data <- RS.eval(rc, \", data, \")\")))\n    RS.close(rc)\n    setkey(data, ADM0_NAME, ADM1_NAME_ALT, ADM2_NAME_ALT)\n  }\n\n  # Rounding (ugly but fast)\n  var <- names(data)[sapply(data, is.numeric)]\n  for(i in var) eval(parse(text=paste0(\"data[, \", i, \" := round(\", i, \", \", vi[i][, dec], \")]\")))\n\n  if (as.class==\"list\") {\n    # Return json with metadata\n    d.names <- vi[names(data)][, list(\n      ColumnCode=varCode,\n      ColumnName=varLabel,\n      ColumnUnit=unit,\n      ColumnDesc=varDesc,\n      ColumnSource=sources)]\n    data <- list(ColumnList=d.names, ValueList=as.matrix(data))\n  }\n\n  return(data)\n}\n\n\n#' Subset, and/or aggregate HarvestChoice 5-arc-minute layers (SQLite version, now deprecated)\n#'\n#' Workhorse method to subset and/or aggregate HarvestChoice layers.\n#' This method also aggregates classified variables by continuous variables.\n#' e.g. \\code{getLayer(var=c(\"whea_h\", \"AEZ16_CLAS\"), by=c(\"ADM2_NAME_ALT\", \"bmi\"))}.\n#' It does so by returning the dominant class of a classified variable within each \\code{by}\n#' class, and by automatically classifying any continuous variable passed to \\code{by}\n#' using value breaks specified as part of each variable metadata.\n#' The formula used to aggregate classified variables by choosing the dominant class is\n#' \\code{names(sort(table({varCode}), decreasing=T)[1])}. This formula computes the\n#' frequency of each class, ranks them by decreasing frequency, and retains the top one.\n#' Layers can also be summarized over a spatial area (passed as WKT point, multipoints, or polygons).\n#'\n#' @param var character array of variable names (all types are accepted)\n#' @param iso3 optional country or regional filter (3-letter code)\n#' @param by optional character array of variables to group by (all types are accepted)\n#' @param wkt optional WKT representation of a spatial object (points or polygons) to summarize over\n#' @param collapse if FALSE always return all pixel values (useful for plotting and spatial formats)\n#' @return a data.table of \\code{var} indicators aggregated by \\code{by}\n#' @export\ngetLayerSQL <- function(var, iso3=\"SSA\", by=NULL, wkt=NULL, collapse=TRUE) {\n\n  setkey(vi, varCode)\n  hc.conn <- dbConnect(SQLite(), dbname=getOption(\"hcdata.path\"), flags=SQLITE_RO)\n\n  if (length(wkt)>0) {\n    # Convert WKT to CELL5M IDs, void any iso3 filter\n    wkt <- getPixelID(wkt)\n    if(length(wkt)>0) iso3 <- \"SSA\"\n    if(class(wkt)==\"SpatialPoints\") collapse <- FALSE\n  }\n\n  if (length(by)>0) {\n    # Aggregate. Make sure to also retrieve all dependent variable(s)\n    vars <- unlist(strsplit(vi[var][, aggCodes], \"|\", fixed=T))\n    vars <- unique(c(g, var, by, vars))\n    data <- dbGetQuery(hc.conn, paste0(\"SELECT \" , paste0(vars, collapse=\", \"), \" FROM dt\"))\n    data <- data.table(data)\n\n    # If `by` include continuous variables, then auto-classify before grouping\n    # Beware that aggregation formulas typically require additional variables from `dt`\n    bynum <- vi[by][!type==\"class\", varCode]\n\n    if (length(bynum)>0) {\n      # Classify using `classBreaks`\n      byclass <- sapply(bynum, function(i) {\n        b <- as.integer(unlist(strsplit(vi[i][, classBreaks], \"|\", fixed=T)))\n        paste0(i, \"=cut(\", i, \", c(\", paste0(b, collapse=\", \"), \"), ordered_result=T)\")\n      })\n\n      by <- c(vi[by][type==\"class\", varCode], byclass)\n      by <- by[!is.na(by)]\n      by <- paste(by, collapse=\", \")\n    }\n\n    # Construct generic aggregation formula\n    setkey(vi, varCode)\n    agg <- vi[var][, aggFunR]\n    agg <- paste(var, agg, sep=\"=\")\n    agg <- paste(agg, collapse=\", \")\n\n    if (collapse==F) {\n      # Aggregate but don't collapse (for plotting and raster formats)\n      agg <- paste0(\"CELL5M, X, Y, \",  paste0(agg, collapse=\", \"))\n    }\n\n    data <- eval(parse(text=paste0(\"data\",\n      if(length(wkt)>0) \"[CELL5M %in% wkt]\",\n      if(iso3!=\"SSA\") \"[ISO3==iso3]\",\n      \"[order(\", by, \", na.last=T)\",\n      \", list(\", agg, \"), by=list(\", by, \")]\")))\n\n  } else {\n    # No aggregation. Don't duplicate variables\n    vars <- c(g, var, by)\n    vars <- unique(vars)\n    vars <- vars[!is.na(vars)]\n    data <- dbGetQuery(hc.conn, paste0(\"SELECT \" , paste0(vars, collapse=\", \"), \" FROM dt\"))\n    data <- data.table(data)\n    data <- data[!is.na(X)]\n    setkey(data, ADM0_NAME, ADM1_NAME_ALT, ADM2_NAME_ALT)\n    if (length(wkt)>0) data <- data[CELL5M %in% wkt]\n    if (iso3!=\"SSA\") data <- data[ISO3==iso3]\n  }\n\n  # Rounding (ugly but fast)\n  var <- names(data)[sapply(data, is.numeric)]\n  for(i in var) eval(parse(text=paste0(\"data[, \", i, \" := round(\", i, \", \", vi[i][, dec], \")]\")))\n  dbDisconnect(hc.conn)\n  return(data)\n}\n",
    "created" : 1437359677464.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2834604479",
    "id" : "85F0EFE6",
    "lastKnownWriteTime" : 1437359794,
    "path" : "/home/projects/ocpu/hcapi3/R/getLayer.R",
    "project_path" : "R/getLayer.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}